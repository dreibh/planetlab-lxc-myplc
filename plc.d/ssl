#!/bin/bash
#
# priority: 400
#
# Generate SSL certificates
#
# Mark Huang <mlhuang@cs.princeton.edu>
# Copyright (C) 2006 The Trustees of Princeton University
#
# $Id: ssl,v 1.10 2006/07/24 19:30:45 mlhuang Exp $
#

# Source function library and configuration
. /etc/plc.d/functions
. /etc/planetlab/plc_config

# Be verbose
set -x

# Print the CNAME of an SSL certificate
ssl_cname ()
{
    openssl x509 -noout -in $1 -subject | \
	sed -n -e 's@.*/CN=\([^/]*\).*@\1@p'
}

# Print the emailAddress of an SSL certificate
ssl_email ()
{
    openssl x509 -noout -in $1 -subject | \
	sed -n -e 's@.*/emailAddress=\([^/]*\).*@\1@p'
}

# Verify a certificate. If invalid, generate a new self-signed
# certificate.
verify_or_generate_certificate() {
    crt=$1
    key=$2
    ca=$3
    cname=$4
    email=$5

    # If the CA certificate does not exist, assume that the
    # certificate is self-signed.
    if [ ! -f $ca ] ; then
	cp -a $crt $ca
    fi

    if [ -f $crt ] ; then
	# Check if certificate is valid
	verify=$(openssl verify -CAfile $ca $crt)
	# Delete if invalid or if the subject has changed
	if grep -q "error" <<<$verify || \
	    [ "$(ssl_cname $crt)" != "$cname" ] || \
	    [ "$(ssl_email $crt)" != "$email" ] ; then
	    rm -f $crt $ca
	fi
    fi

    if [ ! -f $crt ] ; then
        # Set subject
	subj=
	if [ -n "$cname" ] ; then
	    subj="$subj/CN=$cname"
	fi
	if [ -n "$email" ] ; then
	    subj="$subj/emailAddress=$email"
	fi

	# Generate new self-signed certificate
	mkdir -p $(dirname $crt)
	openssl req -new -x509 -days 3650 -set_serial $RANDOM \
	    -batch -subj "$subj" \
	    -nodes -keyout $key -out $crt
	check
	chmod 644 $crt

	# The certificate it self-signed, so it is its own CA
	cp -a $crt $ca
    fi
}

case "$1" in
    start)
	MESSAGE=$"Generating SSL certificates"
	dialog "$MESSAGE"

	# Generate HTTPS certificates if necessary. We generate a
	# certificate for each enabled server with a different
	# hostname. These self-signed certificates may be overridden
	# later.
	for server in WWW API BOOT ; do
	    ssl_key=PLC_${server}_SSL_KEY
	    ssl_crt=PLC_${server}_SSL_CRT
	    ca_ssl_crt=PLC_${server}_CA_SSL_CRT
	    hostname=PLC_${server}_HOST

	    # Check if we have already generated a certificate for
	    # the same hostname.
	    for previous_server in WWW API BOOT ; do
		if [ "$server" = "$previous_server" ] ; then
		    break
		fi
		previous_ssl_key=PLC_${previous_server}_SSL_KEY
		previous_ssl_crt=PLC_${previous_server}_SSL_CRT
		previous_ca_ssl_crt=PLC_${previous_server}_CA_SSL_CRT
		previous_hostname=PLC_${previous_server}_HOST

		if [ -f ${!previous_ssl_crt} ] && \
		    [ "$(ssl_cname ${!previous_ssl_crt})" = "${!hostname}" ] ; then
		    cp -a ${!previous_ssl_key} ${!ssl_key}
		    cp -a ${!previous_ssl_crt} ${!ssl_crt}
		    cp -a ${!previous_ca_ssl_crt} ${!ca_ssl_crt}
		    break
		fi
	    done

	    verify_or_generate_certificate \
		${!ssl_crt} ${!ssl_key} ${!ca_ssl_crt} \
		${!hostname}
	done

	# Install HTTPS certificates into both /etc/pki (Fedora Core
	# 4) and /etc/httpd/conf (Fedora Core 2). If the API, boot,
	# and web servers are all running on the same machine, the web
	# server certificate takes precedence.
	for server in API BOOT WWW ; do
	    enabled=PLC_${server}_ENABLED
	    if [ "${!enabled}" != "1" ] ; then
		continue
	    fi
	    ssl_key=PLC_${server}_SSL_KEY
	    ssl_crt=PLC_${server}_SSL_CRT

	    symlink ${!ssl_crt} /etc/pki/tls/certs/localhost.crt
	    symlink ${!ssl_key} /etc/pki/tls/private/localhost.key
	    symlink ${!ssl_crt} /etc/httpd/conf/ssl.crt/server.crt
	    symlink ${!ssl_key} /etc/httpd/conf/ssl.key/server.key
	done

	result "$MESSAGE"
	;;
esac

exit $ERRORS
