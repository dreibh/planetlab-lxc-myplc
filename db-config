#!/usr/bin/env /usr/bin/plcsh
#
# Bootstraps the PLC database with a default administrator account and
# a default site, defines default slice attribute types, and
# creates/updates default system slices.
#
# Mark Huang <mlhuang@cs.princeton.edu>
# Copyright (C) 2006 The Trustees of Princeton University
#
# $Id: db-config 7454 2007-12-11 18:55:00Z faiyaza $
# $HeadURL$

from plc_config import PLCConfiguration
import sys

def main():
    cfg = PLCConfiguration()
    cfg.load()
    variables = cfg.variables()

    # Load variables into dictionaries
    for category_id, (category, variablelist) in variables.iteritems():
        globals()[category_id] = dict(zip(variablelist.keys(),
                                       [variable['value'] for variable in variablelist.values()]))

    # Create/update the default administrator account (should be
    # person_id 2).
    admin = { 'person_id': 2,
              'first_name': "Default",
              'last_name': "Administrator",
              'email': plc['root_user'],
              'password': plc['root_password'] }
    persons = GetPersons([admin['person_id']])
    if not persons:
        person_id = AddPerson(admin)
        if person_id != admin['person_id']:
            # Huh? Someone deleted the account manually from the database.
            DeletePerson(person_id)
            raise Exception, "Someone deleted the \"%s %s\" account from the database!" % \
                  (admin['first_name'], admin['last_name'])
        UpdatePerson(person_id, { 'enabled': True })
    else:
        person_id = persons[0]['person_id']
        UpdatePerson(person_id, admin)

    # Create/update the default site (should be site_id 1)
    if plc_www['port'] == '80':
        url = "http://" + plc_www['host'] + "/"
    elif plc_www['port'] == '443':
        url = "https://" + plc_www['host'] + "/"
    else:
        url = "http://" + plc_www['host'] + ":" + plc_www['port'] + "/"
    site = { 'site_id': 1,
             'name': plc['name'] + " Central",
             'abbreviated_name': plc['name'],
             'login_base': plc['slice_prefix'],
             'is_public': False,
             'url': url,
             'max_slices': 100 }

    sites = GetSites([site['site_id']])
    if not sites:
        site_id = AddSite(site['name'], site['abbreviated_name'], site['login_base'], site)
        if site_id != site['site_id']:
            DeleteSite(site_id)
            raise Exception, "Someone deleted the \"%s\" site from the database!" % \
                  site['name']
        sites = [site]

    # Must call UpdateSite() even after AddSite() to update max_slices
    site_id = sites[0]['site_id']
    UpdateSite(site_id, site)

    # The default administrator account must be associated with a site
    # in order to login.
    AddPersonToSite(admin['person_id'], site['site_id'])
    SetPersonPrimarySite(admin['person_id'], site['site_id'])

    # Grant admin and PI roles to the default administrator account
    AddRoleToPerson(10, admin['person_id'])
    AddRoleToPerson(20, admin['person_id'])

    # Setup default PlanetLabConf entries
    default_conf_files = [
        # NTP configuration
        {'enabled': True,
         'source': 'PlanetLabConf/ntp.conf.php',
         'dest': '/etc/ntp.conf',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '/etc/rc.d/init.d/ntpd restart',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},
        {'enabled': True,
         'source': 'PlanetLabConf/ntp/step-tickers.php',
         'dest': '/etc/ntp/step-tickers',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '/etc/rc.d/init.d/ntpd restart',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},

        # SSH server configuration
        {'enabled': True,
         'source': 'PlanetLabConf/sshd_config',
         'dest': '/etc/ssh/sshd_config',
         'file_permissions': '600',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '/etc/init.d/sshd restart',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},

        # Administrative SSH keys
        {'enabled': True,
         'source': 'PlanetLabConf/keys.php?root',
         'dest': '/root/.ssh/authorized_keys',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '/bin/chmod 700 /root/.ssh',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},
        {'enabled': True,
         'source': 'PlanetLabConf/keys.php?site_admin',
         'dest': '/home/site_admin/.ssh/authorized_keys',
         'file_permissions': '644',
         'file_owner': 'site_admin',
         'file_group': 'site_admin',
         'preinstall_cmd': 'grep -q site_admin /etc/passwd',
         'postinstall_cmd': '/bin/chmod 700 /home/site_admin/.ssh',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},
        # Log rotation configuration
        {'enabled': True,
         'source': 'PlanetLabConf/logrotate.conf',
         'dest': '/etc/logrotate.conf',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},

        # updatedb/locate nightly cron job
        {'enabled': True,
         'source': 'PlanetLabConf/slocate.cron',
         'dest': '/etc/cron.daily/slocate.cron',
         'file_permissions': '755',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},

        # YUM configuration
        {'enabled': True,
         'source': 'PlanetLabConf/yum.conf.php?gpgcheck=1',
         'dest': '/etc/yum.conf',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},
        {'enabled': True,
         'source': 'PlanetLabConf/delete-rpm-list-production',
         'dest': '/etc/planetlab/delete-rpm-list',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},

        # PLC configuration
        {'enabled': True,
         'source': 'PlanetLabConf/get_plc_config.php',
         'dest': '/etc/planetlab/plc_config',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},
        {'enabled': True,
         'source': 'PlanetLabConf/get_plc_config.php?python',
         'dest': '/etc/planetlab/plc_config.py',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},
        {'enabled': True,
         'source': 'PlanetLabConf/get_plc_config.php?perl',
         'dest': '/etc/planetlab/plc_config.pl',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},
        {'enabled': True,
         'source': 'PlanetLabConf/get_plc_config.php?php',
         'dest': '/etc/planetlab/php/plc_config.php',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},

        # XXX Required for old Node Manager
        # Proper configuration
        {'enabled': True,
         'source': 'PlanetLabConf/propd.conf',
         'dest': '/etc/proper/propd.conf',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '/etc/init.d/proper restart',
         'error_cmd': '',
         'ignore_cmd_errors': True,
         'always_update': False},

        # XXX Required for old Node Manager
        # Bandwidth cap
        {'enabled': True,
         'source': 'PlanetLabConf/bwlimit.php',
         'dest': '/etc/planetlab/bwcap',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '',
         'error_cmd': '',
         'ignore_cmd_errors': True,
         'always_update': False},

        # Proxy ARP setup
        {'enabled': True,
         'source': 'PlanetLabConf/proxies.php',
         'dest': '/etc/planetlab/proxies',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},

        # Firewall configuration
        {'enabled': True,
         'source': 'PlanetLabConf/iptables',
         'dest': '/etc/sysconfig/iptables',
         'file_permissions': '600',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},
        {'enabled': True,
         'source': 'PlanetLabConf/blacklist.php',
         'dest': '/etc/planetlab/blacklist',
         'file_permissions': '600',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '/sbin/iptables-restore --noflush < /etc/planetlab/blacklist',
         'error_cmd': '',
         'ignore_cmd_errors': True,
         'always_update': False},

        # /etc/issue
        {'enabled': True,
         'source': 'PlanetLabConf/issue.php',
         'dest': '/etc/issue',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},

        # Kernel parameters
        {'enabled': True,
         'source': 'PlanetLabConf/sysctl.php',
         'dest': '/etc/sysctl.conf',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '/sbin/sysctl -e -p /etc/sysctl.conf',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},

        # Sendmail configuration
        {'enabled': True,
         'source': 'PlanetLabConf/sendmail.mc',
         'dest': '/etc/mail/sendmail.mc',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},
        {'enabled': True,
         'source': 'PlanetLabConf/sendmail.cf',
         'dest': '/etc/mail/sendmail.cf',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': 'service sendmail restart',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},

        # GPG signing keys
        {'enabled': True,
         'source': 'PlanetLabConf/RPM-GPG-KEY-fedora',
         'dest': '/etc/pki/rpm-gpg/RPM-GPG-KEY-fedora',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': 'rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-fedora',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},
        {'enabled': True,
         'source': 'PlanetLabConf/get_gpg_key.php',
         'dest': '/etc/pki/rpm-gpg/RPM-GPG-KEY-planetlab',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': 'rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-planetlab',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},

        # Ping of death configuration
        # the 'restart' postcommand doesn't work, b/c the pod script doesn't support it.
        {'enabled': True,
         'source': 'PlanetLabConf/ipod.conf.php',
         'dest': '/etc/ipod.conf',
         'file_permissions': '644',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '/etc/init.d/pod start',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False},

        # sudo configuration
        {'enabled': True,
         'source': 'PlanetLabConf/sudoers',
         'dest': '/etc/sudoers',
         'file_permissions': '440',
         'file_owner': 'root',
         'file_group': 'root',
         'preinstall_cmd': '',
         'postinstall_cmd': '/usr/sbin/visudo -c',
         'error_cmd': '',
         'ignore_cmd_errors': False,
         'always_update': False}
        ]

    # Get list of existing (enabled, global) files
    conf_files = GetConfFiles()
    conf_files = filter(lambda conf_file: conf_file['enabled'] and \
                                          not conf_file['node_ids'] and \
                                          not conf_file['nodegroup_ids'],
                        conf_files)
    dests = [conf_file['dest'] for conf_file in conf_files]
    conf_files = dict(zip(dests, conf_files))

    # Create/update default PlanetLabConf entries
    for default_conf_file in default_conf_files:
        if default_conf_file['dest'] not in dests:
            AddConfFile(default_conf_file)
        else:
            conf_file = conf_files[default_conf_file['dest']]
            UpdateConfFile(conf_file['conf_file_id'], default_conf_file)

    # Setup default slice attribute types
    default_attribute_types = [
        # Slice type (only vserver is supported)
        {'name': "type",
         'description': "Type of slice (e.g. vserver)",
         'min_role_id': 20},

        # System slice
        {'name': "system",
         'description': "Is a default system slice (1) or not (0 or unset)",
         'min_role_id': 10},

        # Slice enabled (1) or suspended (0)
        {'name': "enabled",
         'description': "Slice enabled (1 or unset) or suspended (0)",
         'min_role_id': 10},

        # Slice reference image
        {'name': "vref",
         'description': "Reference image",
         'min_role_id': 30},

        # Slice initialization script
        {'name': "initscript",
         'description': "Slice initialization script",
         'min_role_id': 10},

        # CPU share
        {'name': "cpu_pct",
         'description': "Reserved CPU percent",
         'min_role_id': 10},
        {'name': "cpu_share",
         'description': "Number of CPU shares",
         'min_role_id': 10},

        # Bandwidth limits
        {'name': "net_min_rate",
         'description': "Minimum bandwidth (kbps)",
         'min_role_id': 10},
        {'name': "net_max_rate",
         'description': "Maximum bandwidth (kbps)",
         'min_role_id': 10},
        {'name': "net_i2_min_rate",
         'description': "Minimum bandwidth over I2 routes (kbps)",
         'min_role_id': 10},
        {'name': "net_i2_max_rate",
         'description': "Maximum bandwidth over I2 routes (kbps)",
         'min_role_id': 10},
        {'name': "net_max_kbyte",
         'description': "Maximum daily network Tx KByte limit.",
         'min_role_id': 10},
        {'name': "net_thresh_kbyte",
         'description': "KByte limit before warning and throttling.",
         'min_role_id': 10},
        {'name': "net_i2_max_kbyte",
         'description': "Maximum daily network Tx KByte limit to I2 hosts.",
         'min_role_id': 10},
        {'name': "net_i2_thresh_kbyte",
         'description': "KByte limit to I2 hosts before warning and throttling.",
         'min_role_id': 10},
        {'name': "net_share",
         'description': "Number of bandwidth shares",
         'min_role_id': 10},
        {'name': "net_i2_share",
         'description': "Number of bandwidth shares over I2 routes",
         'min_role_id': 10},
 
        # Disk quota
        {'name': "disk_max",
         'description': "Disk quota (1k disk blocks)",
         'min_role_id': 10},

        # Proper operations
        {'name': "proper_op",
         'description': "Proper operation (e.g. bind_socket)",
         'min_role_id': 10}
        ]

    # Get list of existing attribute types
    attribute_types = GetSliceAttributeTypes()
    attribute_types = [attribute_type['name'] for attribute_type in attribute_types]

    # Create/update default slice attribute types
    for default_attribute_type in default_attribute_types:
        if default_attribute_type['name'] not in attribute_types:
            AddSliceAttributeType(default_attribute_type)
        else:
            UpdateSliceAttributeType(default_attribute_type['name'], default_attribute_type)

    # Default Initscripts
    default_initscripts = [
        # Sirius 
        {'enabled': True, 
         'name': plc['slice_prefix'] + "_sirius", 
         'script': '#!/usr/bin/python\n\n"""The Sirius Calendar Service.\n\nThis Python program runs on each node.  It periodically downloads the schedule file and uses NodeManager\'s XML-RPC interface to adjust the priority increase.\n\nAuthor: David Eisenstat (deisenst@cs.princeton.edu)\n\nOriginal Sirius implementation by David Lowenthal.\n"""\n\nimport fcntl\nimport os\nimport random\nimport signal\nimport socket\nimport sys\nimport threading\nimport time\nimport traceback\nimport urllib\nfrom xmlrpclib import ServerProxy\n\n\n# 0 means normal operation\n# 1 means turn on the short time scales and read the schedule from a file\n# 2 means additionally don\'t contact NodeManager\n\nDEBUGLEVEL = 0\n\n########################################\n\nif DEBUGLEVEL < 2:\n    LOGFILE = \'/var/log/sirius\'\nelse:\n    LOGFILE = \'log.txt\'\n\nloglock = threading.Lock()\n\n\ndef log(msg):\n    """Append <msg> and a timestamp to <LOGFILE>."""\n    try:\n        if not msg.endswith(\'\\n\'):\n            msg += \'\\n\'\n        loglock.acquire()\n        try:\n            logfile = open(LOGFILE, \'a\')\n            t = time.time()\n            print >>logfile, t\n            print >>logfile, time.asctime(time.gmtime(t))\n            print >>logfile, msg\n        finally:\n            loglock.release()\n    except:\n        if DEBUGLEVEL > 0:\n            traceback.print_exc()\n\n\ndef logexception():\n    """Log an exception."""\n    log(traceback.format_exc())\n\n########################################\n\nif DEBUGLEVEL > 0:\n    # smaller time units so we can test faster\n    ONEMINUTE = 1\n    ONEHOUR = 10 * ONEMINUTE\nelse:\n    ONEMINUTE = 60\n    ONEHOUR = 60 * ONEMINUTE\n\n\nclass Periodic:\n    """Periodically make a function call."""\n\n    def __init__(self, target, interval, mindelta, maxdelta):\n        self._target = target\n        self._interval = interval\n        self._deltarange = mindelta, maxdelta+1\n        thr = threading.Thread(target=self.run, args=[target])\n        thr.setDaemon(True)\n        thr.start()\n\n    def run(self, target):\n        nextintervalstart = int(time.time() / self._interval) * self._interval\n        while True:\n            try:\n                self._target()\n            except:\n                logexception()\n            nextintervalstart += self._interval\n            nextfiring = nextintervalstart + random.randrange(*self._deltarange)\n            while True:\n                t = time.time()\n                if t < nextfiring:\n                    try:\n                        time.sleep(nextfiring - t)\n                    except:\n                        logexception()\n                else:\n                    break\n\n########################################\n\nSLOTDURATION = ONEHOUR\n\nSCHEDULEURL = \'' + site['url'] + '/planetlab/sirius/schedule.txt\'\n\nschedulelock = threading.Lock()\n\nschedule = {}\n\n\ndef currentslot():\n    return int(time.time() / SLOTDURATION) * SLOTDURATION\n\n\ndef updateschedule():\n    """Make one attempt at downloading and updating the schedule."""\n    log(\'Contacting PLC...\')\n    newschedule = {}\n    # Format is:\n    # timestamp\n    # slicename - starttime - -\n    # ...\n    if DEBUGLEVEL > 0:\n        f = open(\'/tmp/schedule.txt\')\n    else:\n        f = urllib.urlopen(SCHEDULEURL)\n    for line in f:\n        fields = line.split()\n        if len(fields) >= 3:\n            newschedule[fields[2]] = fields[0]\n    log(\'Current schedule is %s\' % newschedule)\n\n    schedulelock.acquire()\n    try:\n        schedule.clear()\n        schedule.update(newschedule)\n    finally:\n        schedulelock.release()\n    log(\'Updated schedule successfully\')\n\n########################################\n\nnodemanager = ServerProxy(\'http://127.0.0.1:812/\')\n\nrecipientcond = threading.Condition()\n\nrecipient = \'\'\nversionnumber = 0\n\ndef updateloans():\n    log(\'Contacting NodeManager...\')\n    schedulelock.acquire()\n    try:\n        newrecipient = schedule.get(str(currentslot()), \'\')\n    finally:\n        schedulelock.release()\n    if newrecipient:\n        loans = [(newrecipient, \'cpu_pct\', 25), (newrecipient, \'net_min_rate\', 2000)]\n    else:\n        loans = []\n    log(\'Current loans are %s\' % loans)\n\n    if DEBUGLEVEL < 2:\n        nodemanager.SetLoans(\'princeton_sirius\', loans)\n    log(\'Updated loans successfully\')\n\n    recipientcond.acquire()\n    try:\n        global recipient, versionnumber\n        if recipient != newrecipient:\n            recipient = newrecipient\n            versionnumber += 1\n            recipientcond.notifyAll()\n    finally:\n        recipientcond.release()\n\n########################################\n\nbackoff = 1\n\ndef success():\n    global backoff\n    backoff = 1\n\ndef failure():\n    global backoff\n    try:\n        time.sleep(backoff)\n    except:\n        logexception()\n    backoff = min(backoff*2, 5*ONEMINUTE)\n\n\ndef handleclient(clientsock, clientaddress):\n    try:\n        log(\'Connection from %s:%d\' % clientaddress)\n        clientsock.shutdown(socket.SHUT_RD)\n        recipientcond.acquire()\n        while True:\n            recip, vn = recipient, versionnumber\n            recipientcond.release()\n            clientsock.send(recip + \'\\n\')\n\n            recipientcond.acquire()\n            while versionnumber == vn:\n                recipientcond.wait()\n    except:\n        logexception()\n\n\ndef server():\n    while True:\n        try:\n            sock = socket.socket()\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            sock.bind((\'\', 8124))\n            sock.listen(5)\n            success()\n            break\n        except:\n            logexception()\n            failure()\n    log(\'Bound server socket\')\n\n    while True:\n        try:\n            client = sock.accept()\n            threading.Thread(target=handleclient, args=client).start()\n            success()\n        except:\n            logexception()\n            failure()\n\n########################################\n\nif DEBUGLEVEL < 2:\n    PIDFILE = \'/tmp/sirius.pid\'\nelse:\n    PIDFILE = \'sirius.pid\'\n\ntry:\n    if os.fork():\n        sys.exit(0)\n    f = open(PIDFILE, \'w\')\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)\nexcept:\n    logexception()\n    sys.exit(1)\n\nPeriodic(updateschedule, SLOTDURATION, -5*ONEMINUTE, -1*ONEMINUTE)\nPeriodic(updateloans, 5*ONEMINUTE, 0, 0)\nserver()\n'}]
    
    # Get list of existing initscripts
    oldinitscripts = GetInitScripts()
    oldinitscripts = [script['name'] for script in oldinitscripts]

    for initscript in default_initscripts:
        if initscript['name'] not in oldinitscripts:  AddInitScript(initscript)

    # Setup default slice attribute types
    default_setting_types = [

        {'category' : "general",
         'name' : "ifname",
         'description': "Set interface name, instead of eth0 or the like",
         'min_role_id' : 40},
        {'category' : "general",
         'name' : "driver",
         'description': "Use this to specify an alternate driver",
         'min_role_id' : 40 },
        {'category' : "general",
         'name' : "alias",
         'description': "Allows to reuse an interface as eth0:alias",
         'min_role_id' : 40},

        {'category' : "hidden",
         'name' : "backdoor",
         'description': "For testing new settings",
         'min_role_id' : 10},
        ] + [
        { "category" : "WiFi",
          "name" : x,
          "description" : "802.11 %s -- see %s"%(y,z),
          "min_role_id" : 40 } for (x,y,z) in [
            ("mode","Mode","iwconfig"),
            ("essid","ESSID","iwconfig"),
            ("nw","Network Id","iwconfig"),
            ("freq","Frequency","iwconfig"),
            ("channel","Channel","iwconfig"),
            ("sens","sensitivity threshold","iwconfig"),
            ("rate","Rate","iwconfig"),
            ("key","key","iwconfig key"),
            ("key1","key1","iwconfig key [1]"),
            ("key2","key2","iwconfig key [2]"),
            ("key3","key3","iwconfig key [3]"),
            ("key4","key4","iwconfig key [4]"),
            ("securitymode","Security mode","iwconfig enc"),
            ("iwconfig","Additional parameters to iwconfig","ifup-wireless"),
            ("iwpriv","Additional parameters to iwpriv","ifup-wireless"),
            ]
        ]


    # Get list of existing attribute types
    setting_types = GetNodeNetworkSettingTypes()
    setting_types = [setting_type['name'] for setting_type in setting_types]

    # Create/update default slice setting types
    for default_setting_type in default_setting_types:
        if default_setting_type['name'] not in setting_types:
            AddNodeNetworkSettingType(default_setting_type)
        else:
            UpdateNodeNetworkSettingType(default_setting_type['name'], default_setting_type)

    # Create/update system slices
    default_slices = [
         # PlanetFlow
        {'name': plc['slice_prefix'] + "_netflow",
         'description': "PlanetFlow Traffic Auditing Service",
         'url': url,
         'instantiation': "plc-instantiated",
         # Renew forever
         'expires': sys.maxint,
         'attributes': [('system', "1"),
                        ('vref', "planetflow"),
                        ('proper_op', "open file=/etc/passwd, flags=r"),
                        ('proper_op', "create_socket"),
                        ('proper_op', "bind_socket")]},
          # Sirius
        {'name': plc['slice_prefix'] + "_sirius",
         'description': 'The Sirius Calendar Service.\n\nSirius provides system-wide reservations of 25% CPU and 2Mb/s outgoing\nbandwidth.  Sign up for hour-long slots using the Web GUI at the\nPlanetLab website.\n\nThis slice should not generate traffic external to PlanetLab.\n',
         'url': url,
         'instantiation': "plc-instantiated",
         # Renew forever
         'expires': sys.maxint,
         'attributes': [('system', "1"),
                        ('net_min_rate', "2000"),
                        ('cpu_pct', "25"),
                        ('initscript', plc['slice_prefix'] + "_sirius")]}
        ]
    
    for default_slice in default_slices:
        slices = GetSlices([default_slice['name']])
        if slices:
            slice = slices[0]
            UpdateSlice(slice['slice_id'], default_slice)
        else:
            AddSlice(default_slice)
            slice = GetSlices([default_slice['name']])[0]

        # Create/update all attributes
        slice_attributes = []
        if slice['slice_attribute_ids']:
            # Delete unknown attributes
            for slice_attribute in GetSliceAttributes(slice['slice_attribute_ids']):
                if (slice_attribute['name'], slice_attribute['value']) \
                   not in default_slice['attributes']:
                    DeleteSliceAttribute(slice_attribute['slice_attribute_id'])
                else:
                    slice_attributes.append((slice_attribute['name'], slice_attribute['value']))

        for (name, value) in default_slice['attributes']:
            if (name, value) not in slice_attributes:
                AddSliceAttribute(slice['name'], name, value)

    installfailed = """
Once the node meets these requirements, please reinitiate the install
by visiting:

https://%(PLC_WWW_HOST)s:%(PLC_WWW_SSL_PORT)d/db/nodes/?id=%(node_id)d

Update the BootState to 'Reinstall', then reboot the node.

If you have already performed this step and are still receiving this
message, please reply so that we may investigate the problem.
"""

    # Load default message templates
    message_templates = [
        {'message_id': 'Verify account',
         'subject': "Verify account registration",
         'template': """
Please verify that you registered for a %(PLC_NAME)s account with the
username %(email)s by visiting:

https://%(PLC_WWW_HOST)s:%(PLC_WWW_SSL_PORT)d/db/persons/register.php?id=%(person_id)d&key=%(verification_key)s

If you did not register for a %(PLC_NAME)s account, please ignore this
message, or contact %(PLC_NAME)s Support <%(PLC_MAIL_SUPPORT_ADDRESS)s>.
"""
         },

        {'message_id': 'New PI account',
         'subject': "New PI account registration from %(first_name)s %(last_name)s <%(email)s> at %(site_name)s",
         'template': """
%(first_name)s %(last_name)s <%(email)s> has signed up for a new
%(PLC_NAME)s account at %(site_name)s and has requested a PI role. PIs
are responsible for enabling user accounts, creating slices, and
ensuring that all users abide by the %(PLC_NAME)s Acceptable Use
Policy.

Only %(PLC_NAME)s administrators may enable new PI accounts. If you
are a PI at %(site_name)s, please respond and indicate whether this
registration is acceptable.

To view the request, visit:

https://%(PLC_WWW_HOST)s:%(PLC_WWW_SSL_PORT)d/db/persons/index.php?id=%(person_id)d
"""
         },

        {'message_id': 'New account',
         'subject': "New account registration from %(first_name)s %(last_name)s <%(email)s> at %(site_name)s",
         'template': """
%(first_name)s %(last_name)s <%(email)s> has signed up for a new
%(PLC_NAME)s account at %(site_name)s and has requested the following
roles: %(roles)s.

To deny the request or enable the account, visit:

https://%(PLC_WWW_HOST)s:%(PLC_WWW_SSL_PORT)d/db/persons/index.php?id=%(person_id)d
"""
         },

        {'message_id': 'Password reset requested',
         'subject': "Password reset requested",
         'template': """
Someone has requested that the password of your %(PLC_NAME)s account
%(email)s be reset. If this person was you, you may continue with the
reset by visiting:

https://%(PLC_WWW_HOST)s:%(PLC_WWW_SSL_PORT)d/db/persons/reset_password.php?id=%(person_id)d&key=%(verification_key)s

If you did not request that your password be reset, please contact
%(PLC_NAME)s Support <%(PLC_MAIL_SUPPORT_ADDRESS)s>. Do not quote or
otherwise include any of this text in any correspondence.
"""
         },

        {'message_id': 'Password reset',
         'subject': "Password reset",
         'template': """
The password of your %(PLC_NAME)s account %(email)s has been
temporarily reset to:

%(password)s

Please change it at as soon as possible by visiting:

https://%(PLC_WWW_HOST)s:%(PLC_WWW_SSL_PORT)d/db/persons/index.php?id=%(person_id)d

If you did not request that your password be reset, please contact
%(PLC_NAME)s Support <%(PLC_MAIL_SUPPORT_ADDRESS)s>. Do not quote or
otherwise include any of this text in any correspondence.
"""
         },

        # Boot Manager messages
        {'message_id': "installfinished",
         'subject': "%(hostname)s completed installation",
         'template': """
%(hostname)s just completed installation.

The node should be usable in a couple of minutes if installation was
successful.
"""
         },

        {'message_id': "insufficientdisk",
         'subject': "%(hostname)s does not have sufficient disk space",
         'template': """
%(hostname)s failed to boot because it does not have sufficent disk
space, or because its disk controller was not recognized.

Please replace the current disk or disk controller or install
additional disks to meet the current hardware requirements.
""" + installfailed
         },

        {'message_id': "insufficientmemory",
         'subject': "%(hostname)s does not have sufficient memory",
         'template': """
%(hostname)s failed to boot because it does not have sufficent
memory.

Please install additional memory to meet the current hardware
requirements.
""" + installfailed
         },

        {'message_id': "authfail",
         'subject': "%(hostname)s failed to authenticate",
         'template':
"""
%(hostname)s failed to authenticate for the following reason:

%(fault)s

The most common reason for authentication failure is that the
authentication key stored in the node configuration file, does not
match the key on record. 

There are two possible steps to resolve the problem.

1. If you have used an All-in-one BootCD that includes the plnode.txt file,
    then please check your machine for any old boot media, either in the
    floppy drive, or on a USB stick.  It is likely that an old configuration
    is being used instead of the new configuration stored on the BootCD.
Or, 
2. If you are using Generic BootCD image, then regenerate the node 
    configuration file by visiting:

    https://%(PLC_WWW_HOST)s:%(PLC_WWW_SSL_PORT)d/db/nodes/?id=%(node_id)d

    Under 'Download', follow the 'Download plnode.txt file for %(hostname)s'
    option, and save the downloaded file as plnode.txt on either a floppy 
    disk or a USB flash drive.  Be sure the 'Boot State' is set to 'Boot', 
    and, then reboot the node.

If you have already performed this step and are still receiving this
message, please reply so that we can help investigate the problem.
"""
         },

        {'message_id': "notinstalled",
         'subject': "%(hostname)s is not installed",
         'template':
"""
%(hostname)s failed to boot because it has either never been
installed, or the installation is corrupt.

Please check if the hard drive has failed, and replace it if so. After
doing so, visit:

https://%(PLC_WWW_HOST)s:%(PLC_WWW_SSL_PORT)d/db/nodes/?id=%(node_id)d

Change the 'Boot State' to 'Reinstall', and then reboot the node.

If you have already performed this step and are still receiving this
message, please reply so that we may investigate the problem.
"""
         },

        {'message_id': "hostnamenotresolve",
         'subject': "%(hostname)s does not resolve",
         'template':
"""
%(hostname)s failed to boot because its hostname does not resolve, or
does resolve but does not match its configured IP address.

Please check the network settings for the node, especially its
hostname, IP address, and DNS servers, by visiting:

https://%(PLC_WWW_HOST)s:%(PLC_WWW_SSL_PORT)d/db/nodes/?id=%(node_id)d

Correct any errors, and change the 'Boot State' to 'Reinstall', and then
reboot the node.

If you have already performed this step and are still receiving this
message, please reply so that we may investigate the problem.
"""
         },

        # XXX N.B. I don't think these are necessary, since there's no
        # way that the Boot Manager would even be able to contact the
        # API to send these messages.

        {'message_id': "noconfig",
         'subject': "%(hostname)s does not have a configuration file",
         'template': """
%(hostname)s failed to boot because it could not find a PlanetLab
configuration file. To create this file, visit:

https://%(PLC_WWW_HOST)s:%(PLC_WWW_SSL_PORT)d/db/nodes/?id=%(node_id)d

Click the Configuration File link, and save the downloaded file as
plnode.txt on either a floppy disk or a USB flash drive.  Change the 
'Boot State' to 'Reinstall', and then reboot the node.

If you have already performed this step and are still receiving this
message, please reply so that we may investigate the problem.
"""
         },

        {'message_id': "nodetectednetwork",
         'subject': "%(hostname)s has unsupported network hardware",
         'template':
"""

%(hostname)s failed to boot because it has network hardware that is
unsupported by the current production kernel. If it has booted
successfully in the past, please try re-installing it by visiting:

https://%(PLC_WWW_HOST)s:%(PLC_WWW_SSL_PORT)d/db/nodes/?id=%(node_id)d

Change the 'Boot State' to 'Reinstall', and then reboot the node.

If you have already performed this step and are still receiving this
message, please reply so that we may investigate the problem.
"""
         },
        ]

    for template in message_templates:
        messages = GetMessages([template['message_id']])
        if not messages:
            AddMessage(template)

    
    ### Setup Initial PCU information
    pcu_types = [{'model': 'AP79xx',
          'name': 'APC AP79xx',
          'pcu_protocol_types': [{ 'port': 80,
                                  'protocol': 'APC79xxHttp',
                                  'supported': False},
                                 { 'port': 23,
                                  'protocol': 'APC79xx',
                                  'supported': True},
                                 { 'port': 22,
                                  'protocol': 'APC79xx',
                                  'supported': True}],
          },
         {'model': 'Masterswitch',
          'name': 'APC Masterswitch',
          'pcu_protocol_types': [{ 'port': 80,
                                  'protocol': 'APCMasterHttp',
                                  'supported': False},
                                 { 'port': 23,
                                  'protocol': 'APCMaster',
                                  'supported': True},
                                 { 'port': 22,
                                  'protocol': 'APCMaster',
                                  'supported': True}],
          },
         {'model': 'DS4-RPC',
          'name': 'BayTech DS4-RPC',
          'pcu_protocol_types': [{ 'port': 80,
                                  'protocol': 'BayTechHttp',
                                  'supported': False},
                                 { 'port': 23,
                                  'protocol': 'BayTech',
                                  'supported': True},
                                 { 'port': 22,
                                  'protocol': 'BayTech',
                                  'supported': True}],
          },
         {'model': 'IP-41x_IP-81x',
          'name': 'Dataprobe IP-41x & IP-81x',
          'pcu_protocol_types': [ { 'port': 23,
                                  'protocol': 'IPALTelnet',
                                  'supported': True},
                                  { 'port': 80,
                                  'protocol': 'IPALHttp',
                                  'supported': False}],
          },
         {'model': 'DRAC3',
          'name': 'Dell RAC Version 3',
          'pcu_protocol_types': [],
          },
         {'model': 'DRAC4',
          'name': 'Dell RAC Version 4',
          'pcu_protocol_types': [{ 'port': 443,
                                  'protocol': 'DRACRacAdm',
                                  'supported': True},
                                 { 'port': 80,
                                  'protocol': 'DRACRacAdm',
                                  'supported': False},
                                 { 'port': 22,
                                  'protocol': 'DRAC',
                                  'supported': True}],
          },
         {'model': 'ePowerSwitch',
          'name': 'ePowerSwitch 1/4/8x',
          'pcu_protocol_types': [{ 'port': 80,
                                  'protocol': 'ePowerSwitch',
                                  'supported': True}],
          },
         {'model': 'ilo2',
          'name': 'HP iLO2 (Integrated Lights-Out)',
          'pcu_protocol_types': [{ 'port': 443,
                                  'protocol': 'HPiLOHttps',
                                  'supported': True},
                                 { 'port': 22,
                                  'protocol': 'HPiLO',
                                  'supported': True}],
          },
         {'model': 'ilo1',
          'name': 'HP iLO version 1',
          'pcu_protocol_types': [],
          },
         {'model': 'PM211-MIP',
          'name': 'Infratec PM221-MIP',
          'pcu_protocol_types': [],
          },
         {'model': 'AMT2.5',
          'name': 'Intel AMT v2.5 (Active Management Technology)',
          'pcu_protocol_types': [],
          },
         {'model': 'AMT3.0',
          'name': 'Intel AMT v3.0 (Active Management Technology)',
          'pcu_protocol_types': [],
          },
         {'model': 'WTI_IPS-4',
          'name': 'Western Telematic (WTI IPS-4)',
          'pcu_protocol_types': [],
          },
         {'model': 'unknown',
          'name': 'Unknown Vendor or Model',
          'pcu_protocol_types': [{ 'port': 443,
                                  'protocol': 'UnknownPCU',
                                  'supported': False},
                                 { 'port': 80,
                                  'protocol': 'UnknownPCU',
                                  'supported': False},
                                 { 'port': 23,
                                  'protocol': 'UnknownPCU',
                                  'supported': False},
                                 { 'port': 22,
                                  'protocol': 'UnknownPCU',
                                  'supported': False}],
          }]

    # Get all model names
    pcu_models = [type['model'] for type in GetPCUTypes()]
    for type in pcu_types:
        protocol_types = type['pcu_protocol_types']
        # Take this value out of the struct.
        del type['pcu_protocol_types']
        if type['model'] not in pcu_models:
            # Add the name/model info into DB
            id = AddPCUType(type)
            # for each protocol, also add this.
            for ptype in protocol_types:
                AddPCUProtocolType(id, ptype)


if __name__ == '__main__':
    main()

# Local variables:
# tab-width: 4
# mode: python
# End:
