#!/bin/bash
#
# plc	Manages all PLC services on this machine
#
# chkconfig: 2345 5 99
#
# description:	Manages all PLC services on this machine
#
# $Id: guest.init,v 1.15 2006/04/10 21:09:02 mlhuang Exp $
#

# Source function library and configuration
. /etc/plc.d/functions

# Verbosity
verbose=0

# All steps should be idempotent. This means that you should be able
# to run them multiple times without depending on anything previously
# being run. The idea is that when the configuration changes, "service
# plc restart" is called, all dependencies are fixed up, and
# everything just works.
steps=($(
for step in /etc/plc.d/* ; do
    if [ -f $step -a -x $step ] ; then
	priority=$(sed -ne 's/# priority: \(.*\)/\1/p' $step)
	echo $priority $(basename $step)
    fi
done | sort -n | cut -d' ' -f2
))
nsteps=${#steps[@]}

# Regenerate configuration files
reload ()
{
    # Regenerate the main configuration file from default values
    # overlaid with site-specific and current values.
    tmp=$(mktemp /tmp/plc_config.xml.XXXXXX)
    plc-config --xml \
	/etc/planetlab/default_config.xml \
	/etc/planetlab/configs/* \
	/etc/planetlab/plc_config.xml \
	>$tmp
    if [ $? -eq 0 ] ; then
	mv $tmp /etc/planetlab/plc_config.xml
	chmod 644 /etc/planetlab/plc_config.xml
    else
	echo "PLC: Warning: Invalid configuration file(s) detected"
	rm -f $tmp
    fi

    # Shell constants
    plc-config --shell >/etc/planetlab/plc_config
    . /etc/planetlab/plc_config

    # Generate various defaults
    if [ -z "$PLC_DB_PASSWORD" ] ; then
	PLC_DB_PASSWORD=$(uuidgen)
	plc-config --category=plc_db --variable=password --value="$PLC_DB_PASSWORD" --save
    fi

    if [ -z "$PLC_API_MAINTENANCE_PASSWORD" ] ; then
	PLC_API_MAINTENANCE_PASSWORD=$(uuidgen)
	plc-config --category=plc_api --variable=maintenance_password --value="$PLC_API_MAINTENANCE_PASSWORD" --save
    fi

    # Need to configure network before resolving hostnames
    /etc/plc.d/network start 3>/dev/null 4>/dev/null

    PLC_API_MAINTENANCE_SOURCES=$(
	for server in API BOOT WWW ; do
	    hostname=PLC_${server}_HOST
	    gethostbyname ${!hostname}
	done | sort -u
    )
    plc-config --category=plc_api --variable=maintenance_sources --value="$PLC_API_MAINTENANCE_SOURCES" --save

    # Save configuration
    mkdir -p /etc/planetlab/php
    plc-config --php >/etc/planetlab/php/plc_config.php
    plc-config --shell >/etc/planetlab/plc_config

    # For backward compatibility, until we can convert all code to use
    # the now standardized variable names.

    # DB constants are all named the same
    ln -sf plc_config /etc/planetlab/plc_db

    # API constants
    cat >/etc/planetlab/plc_api <<EOF
PL_API_SERVER='$PLC_API_HOST'
PL_API_PATH='$PLC_API_PATH'
PL_API_PORT=$PLC_API_PORT
PL_API_CAPABILITY_AUTH_METHOD='capability'
PL_API_CAPABILITY_PASS='$PLC_API_MAINTENANCE_PASSWORD'
PL_API_CAPABILITY_USERNAME='$PLC_API_MAINTENANCE_USER'
PL_API_TICKET_KEY_FILE='$PLC_API_SSL_KEY'
PLANETLAB_SUPPORT_EMAIL='$PLC_MAIL_SUPPORT_ADDRESS'
BOOT_MESSAGES_EMAIL='$PLC_MAIL_BOOT_ADDRESS'
WWW_BASE='$PLC_WWW_HOST'
BOOT_BASE='$PLC_BOOT_HOST'
EOF

    # API expects root SSH public key to be at /etc/planetlab/node_root_key
    ln -sf "$PLC_ROOT_SSH_KEY_PUB" /etc/planetlab/node_root_key

    # The format is
    #
    # ip:max_role_id:organization_id:password
    #
    # It is unlikely that we will let federated sites use the
    # maintenance account to access each others' APIs, so we always
    # set organization_id to -1.
    (
	echo -n "PL_API_CAPABILITY_SOURCES='"
	first=1
	for ip in $PLC_API_MAINTENANCE_SOURCES ; do
	    if [ $first -ne 1 ] ; then
		echo -n " "
	    fi
	    first=0
	    echo -n "$ip:-1:-1:$PLC_API_MAINTENANCE_PASSWORD"
	done
	echo "'"
    ) >>/etc/planetlab/plc_api

    cat >/etc/planetlab/php/site_constants.php <<"EOF"
<?php
include('plc_config.php');

define('PL_API_SERVER', PLC_API_HOST);
define('PL_API_PATH', PLC_API_PATH);
define('PL_API_PORT', PLC_API_PORT);
define('PL_API_CAPABILITY_AUTH_METHOD', 'capability');
define('PL_API_CAPABILITY_PASS', PLC_API_MAINTENANCE_PASSWORD);
define('PL_API_CAPABILITY_USERNAME', PLC_API_MAINTENANCE_USER);
define('WWW_BASE', PLC_WWW_HOST);
define('BOOT_BASE', PLC_BOOT_HOST);
define('DEBUG', PLC_WWW_DEBUG);
define('API_CALL_DEBUG', PLC_API_DEBUG);
define('SENDMAIL', PLC_MAIL_ENABLED);
define('PLANETLAB_SUPPORT_EMAIL', PLC_NAME . 'Support <' . PLC_MAIL_SUPPORT_ADDRESS . '>');
define('PLANETLAB_SUPPORT_EMAIL_ONLY', PLC_MAIL_SUPPORT_ADDRESS);
?>
EOF
}

usage()
{
    echo "Usage: $0 [OPTION]... [COMMAND] [STEP]..."
    echo "	-v		Be verbose"
    echo "	-h		This message"
    echo
    echo "Commands:"
    echo "	start		Start all PLC subsystems"
    echo "	stop		Stop all PLC subsystems"
    echo "	reload		Regenerate configuration files"
    echo "	restart		Restart all PLC subsystems"
    echo
    echo "Steps:"
    for step in "${steps[@]}" ; do
	if [ -x /etc/plc.d/$step ] ; then
	    echo "	$(basename $step)"
	fi
    done
    exit 1
}

# Get options
while getopts "vh" opt ; do
    case $opt in
	v)
	    verbose=1
	    ;;
	h|*)
	    usage
	    ;;
    esac
done

# Redirect stdout and stderr of each step to /var/log/boot.log
if [ $verbose -eq 0 ] ; then
    exec 1>>/var/log/boot.log
    exec 2>>/var/log/boot.log
fi

# Get command
shift $(($OPTIND - 1))
if [ -z "$1" ] ; then
    usage
fi
command=$1

# Get step(s)
shift 1
if [ -z "$1" ] ; then
    # Start or stop everything. Regenerate configuration first.
    reload
else
    # Start or stop a particular step
    steps=("$@")
    nsteps=${#steps[@]}
fi

RETVAL=0

start ()
{
    for step in "${steps[@]}" ; do
	if [ -x /etc/plc.d/$step ] ; then
	    /etc/plc.d/$step start
	else
	    echo "PLC: $step: unrecognized step" >&4
	    exit 1
	fi
    done
}

stop ()
{
    for i in $(seq 1 $nsteps) ; do
	step=${steps[$(($nsteps - $i))]}
	if [ -x /etc/plc.d/$step ] ; then
	    /etc/plc.d/$step stop
	else
	    echo "PLC: $step: unrecognized step" >&4
	    exit 1
	fi
    done
}

case "$command" in
    start|stop)
	$command
	;;

    restart)
	stop
	start
	;;

    reload)
	;;

    *)
	usage >&3
	;;
esac

exit $RETVAL
